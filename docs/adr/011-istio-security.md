# ADR 011: Service Mesh Ingress & Declarative Security / Ingress de Service Mesh y Seguridad Declarativa

**Date/Fecha:** 2025-12-14
**Status:** Accepted / Aceptado
**Supersedes:** ADR 007, ADR 009

## Context / Contexto
We need a production-grade, low-latency mechanism to route traffic to our microservices and enforce **Zero Trust** security (validating JWT identities) before business logic executes. Previous attempts using imperative AWS Lambda functions (ADR 007, ADR 009) introduced maintenance complexity and latency.
Necesitamos un mecanismo de baja latencia y grado de producción para enrutar tráfico a nuestros microservicios y forzar seguridad **Zero Trust** (validar identidades JWT) antes de que se ejecute la lógica de negocio. Intentos previos usando funciones imperativas AWS Lambda (ADR 007, ADR 009) introdujeron complejidad de mantenimiento y latencia.

## Decision / Decisión
We will adopt a **Cloud-Native Ingress & Security Strategy** using **Istio Service Mesh**.
Adoptaremos una **Estrategia de Ingress y Seguridad Nativa en la Nube** usando **Istio Service Mesh**.

1.  **Traffic Routing (Ingress):** We will use the **Istio Ingress Gateway** (Envoy Proxy) as the single entry point to the cluster. / Usaremos el **Istio Ingress Gateway** (Envoy Proxy) como punto de entrada único al cluster.
2.  **Authentication (AuthN):** We will apply `RequestAuthentication` policies. The Sidecar/Gateway will cryptographically validate JWTs using **JWKS (JSON Web Key Sets)** fetched automatically from the **Auth Service**. / Aplicaremos políticas `RequestAuthentication`. El Sidecar/Gateway validará criptográficamente los JWTs usando **JWKS** obtenidos automáticamente del **Auth Service**.
3.  **Authorization (AuthZ):** We will apply `AuthorizationPolicy` to explicitly allow or deny access to specific paths based on the presence of a valid principal. / Aplicaremos `AuthorizationPolicy` para permitir o denegar explícitamente el acceso a rutas específicas basado en la presencia de un principal válido.

## Rationale / Justificación
* **Performance (FinOps):** Envoy (C++) performs JWT validation in microseconds, significantly faster than a Node.js runtime (Lambda) or a Java Thread (Spring Security Filter). / Envoy (C++) realiza la validación JWT en microsegundos, significativamente más rápido que un runtime Node.js (Lambda) o un Hilo Java (Spring Security Filter).
* **Configuration as Code:** Security is defined in YAML manifests (`kubernetes/security/`), enabling GitOps and auditability, rather than hidden in custom proxy code. / La seguridad se define en manifiestos YAML, habilitando GitOps y auditoría, en lugar de estar oculta en código de proxy personalizado.
* **Separation of Concerns:** Business logic (Java) no longer needs to parse cryptographic signatures, focusing only on fine-grained permissions (Roles). / La lógica de negocio (Java) ya no necesita parsear firmas criptográficas, enfocándose solo en permisos de grano fino (Roles).

## Consequences / Consecuencias
* **Requirement:** The `auth-service` must expose a public, unauthenticated endpoint at `/.well-known/jwks.json` serving the Public RSA Key. / El `auth-service` debe exponer un endpoint público no autenticado en `/.well-known/jwks.json` sirviendo la Clave Pública RSA.
* **Observability:** Failed authentications are now visible in Kiali and Prometheus metrics as 401 errors generated by the mesh. / Las autenticaciones fallidas ahora son visibles en métricas de Kiali y Prometheus como errores 401 generados por la malla.